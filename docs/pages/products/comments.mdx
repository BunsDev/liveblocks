---
meta:
  title: "Comments"
  parentTitle: "Products"
  description:
    "Embed a customizable commenting experience into your product to enable
    people to collaborate."
---

Embed a customizable commenting experience into your product to enable people to
collaborate. Liveblocks Comments is fully customizable, enabling you to create
all kinds of commenting experiences that look and feel like your product. With
Comments, you can build things like mentions, thread resolution, text
annotations, video annotations, and more.

<Banner title="Public beta">

Comments is currently in beta. If you have any questions or feedback, please
reach out to us via the dedicated Discord channel,
[#comments-beta](https://discord.com/channels/913109211746009108/1126614905160749097).
We‚Äôd love to hear from you.

</Banner>

## Comments API Reference

<ListGrid columns={2}>
  <DocsCard
    type="technology"
    title="React"
    href="/docs/api-reference/liveblocks-react#Comments"
    description="@liveblocks/react"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="React Comments"
    href="/docs/api-reference/liveblocks-react-comments"
    description="@liveblocks/react-comments"
    visual={<DocsReactIcon />}
  />
  <DocsCard
    type="technology"
    title="REST API functions"
    href="/docs/api-reference/liveblocks-node#Comments"
    description="@liveblocks/node"
    visual={<DocsApiIcon />}
  />
  <DocsCard
    type="technology"
    title="REST API"
    href="/docs/api-reference/rest-api-endpoints#Comments"
    description="HTTP endpoints"
    visual={<DocsApiIcon />}
  />
</ListGrid>

### Examples using Comments

<ListGrid columns={2}>
  <ExampleCard
    example={{
      title: "Comments",
      slug: "comments/nextjs-comments",
      image: "/images/examples/thumbnails/comments.jpg",
    }}
    technologies={["nextjs", "react"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Video Comments",
      slug: "video-comments/nextjs-comments-video",
      image: "/images/examples/thumbnails/comments-video.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Overlay Comments",
      slug: "overlay-comments/nextjs-comments-overlay",
      image: "/images/examples/thumbnails/comments-overlay.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
  <ExampleCard
    example={{
      title: "Text Editor Comments",
      slug: "text-editor-comments/nextjs-comments-tiptap",
      image: "/images/examples/thumbnails/comments-text-editor.png",
    }}
    technologies={["nextjs"]}
    openInNewWindow
  />
</ListGrid>

## Concepts

### Threads

<Figure>
  <Image
    src="/assets/comments/thread.png"
    alt="Thread"
    width={768}
    height={446}
  />
</Figure>

A thread contains a list of comments sorted by creation date. Threads are always
attached to a room.

### Comments

<Figure>
  <Image
    src="/assets/comments/comment.png"
    alt="Comment"
    width={768}
    height={446}
  />
</Figure>

### Inbox notification

[TODO]: # "Add InboxNotification image"

Inbox notifications are what a user usually sees when clicking on a bell icon üîî
in an app.

A single inbox notification groups all the activities that have occurred in a
single thread. Each inbox notification belongs to a single user. When an inbox
notification is marked as read, the associated thread is also marked as read.
The opposite is also true; when a thread is marked as read, the associated inbox
notification is marked as read.

#### Notification settings

By default, a user will receive a notification if:

- They‚Äôve been mentioned in a thread.
- A user has posted a comment in a thread they‚Äôve been participating in.

[TODO]: # "Insert image showing room notification settings like Notion or Figma"

You can override the default behavior by
[changing notification settings](/docs/api-reference/liveblocks-react#useUpdateRoomNotificationSettings)
at room level, and per user. This is particularly helpful in certain situations.
For example, if a user creates a document, they will likely wish to receive
notification for every new thread inside the document, not only when they‚Äôre
mentioned.

If a user decides to mute notifications for a room, new comments will not create
or update inbox notifications.

#### Emails

[TODO]: # "Insert InboxNotification email default template"

Liveblocks Comments does not directly send emails as we recognize that most
users already have their own branded email infrastructure already, and they may
not wish to share more user data than necessary, for compliance reasons (GDPR,
SOC 2).

Instead, Comments does as much as possible to help you handle email
notifications without actually sending the emails. With Comments webhooks you
can trigger sending emails to your users on certain helpful events, using
provided utilities to help you craft your email templates.

```ts
import { Liveblocks, WebhookHandler } from "@liveblocks/node";

// Add your webhook secret key from a project's webhooks dashboard
const WEBHOOK_SECRET = "YOUR_WEBHOOK_SECRET";
const webhookHandler = new WebhookHandler(WEBHOOK_SECRET);

const liveblocks = new Liveblocks({
  // Add your secret key from a project's API keys dashboard
  secret: "{{SECRET_KEY}}",

  // Email notification configuration
  emailNotification: {
    // Return users info (name, avatar, etc)
    resolveUsers: ({ userIds }) => __getUsers__(userIds),

    // Return the email associated to the user id
    resolveUserEmail: (userId) => __getUserEmail__(userId),

    // Return the link of thread associated to the notification.
    // The user will navigate to this link
    threadUrl: ({ roomId, threadId }) =>
      `https://acme.com/docs/${roomId}?threadId=${threadId}`,

    // Optional template customization using react-email
    // ...
  },
});

export async function POST(request: Request) {
  const body = await request.json();
  const headers = request.headers;

  // Verify if this is a secured webhook request
  // ...

  if (event.type === "emailNotification") {
    const { to, subject, html } = liveblocks.buildEmail({
      event,
    });

    const data = await __sendEmail__({
      from: "Acme <hello@acme.com>",
      to,
      subject,
      html,
    });
  }

  return new Response(null, { status: 200 });
}
```

## Overview

### No need to synchronize your users‚Äô info with Liveblocks

When posting a comment, we do not store the author name or avatar. We only store
the author‚Äôs user ID. We believe that it‚Äôs easier for you to retrieve users
metadata when needed instead of synchronizing your database of users with
Liveblocks.

```tsx
createRoomContext(client, {
  resolveUsers: async ({ userIds }) => {
    // Fetch user metadata from a local cache or a backend endpoint

    return userIds.map((userId) => ({
      name: "Marie Curie",
      avatar: "/images/marie-curie.png",
    }));
  },
});
```

### Metadata

With the ability to attach metadata to threads, you can tailor your commenting
experience to your specific needs by refining and shaping it.

Some examples of custom requirements include:

- Anchor threads to specific spots on your platform for contextual discussions
  linked to any aspect of your product.
- Label your threads based on your business logic, like status, priority and
  category.

```tsx
// Example to annotate a video at a specific timestamp
createThread({
  body,
  metadata: {
    timestamp: 42,
  },
});

// Example to start a thread on a specific element in your document
createThread({
  body,
  metadata: {
    elementId: "xxx",
  },
});
```

### Deletion

Deleting a comment from the client only soft deletes it: `comment.body` is
removed and `comment.deletedAt` is added. We keep a placeholder so that the
missing comments can still be noticed, giving you the choice on how to display
deleted comments: either through a clear ‚Äúmessage deleted‚Äù indicator or by not
displaying it. Note that a thread is fully deleted when all its comments have
been deleted.

### Components

To build comments in your application, you have two primary design
implementation pathways:

#### Default components

- Opinionated components that work out-of-the-box.
- Customizable but optional (and overridable) default styles, including support
  for dark mode.

```tsx file="App.tsx" highlight="1,3,10,12"
import "@liveblocks/react-comments/styles.css";
import { useThreads } from "./liveblocks.config";
import { Composer, Thread } from "@liveblocks/react-comments";

export function App() {
  const { threads } = useThreads();
  return (
    <div>
      {threads.map((thread) => (
        <Thread key={thread.id} thread={thread} />
      ))}
      <Composer />
    </div>
  );
}
```

#### Primitives

- Headless, unstyled components.
- Accessible building blocks to fully customize the experience if CSS is not
  enough.

```tsx file="CustomComment.tsx" highlight="1,8,10"
import { Comment, Timestamp } from "@liveblocks/react-comments/primitives";

export function CustomComment({ comment }) {
  return (
    <div>
      <div>
        <span>{comment.userId}</span>
        <Timestamp date={comment.createdAt} />
      </div>
      <Comment.Body body={comment.body} />
    </div>
  );
}
```

##### Inspired by Radix

Our admiration for [Radix](https://www.radix-ui.com/) runs deep. Their approach
to low-level components and composition has been a beacon of inspiration as we
crafted the primitives.

#### Combining default components and primitives

Note that these two options are not separate paths. Both approaches can be
combined to suit your needs for both speed (default components) and
customization (primitives). One could imagine building their own `<Comment />`
component from scratch using the primitives and still use the default
`<Composer />` component.

### Webhooks

Webhooks are the foundation for extending Liveblocks in any way you want. You
can subscribe to any Comments-related events, such as creation, edition and
deletion.

With Webhooks, you can leverage your own email marketing tool to send emails,
apply your product‚Äôs branding, choose your notification strategy, or even
synchronize threads in Slack.

To start using Webhooks, please follow
[the general guide](/docs/platform/webhooks) and/or take a look at
[the specific guide about email notifications when comments are created](/docs/guides/how-to-send-email-notifications-when-comments-are-created).
