import { readFileSync } from "fs";
import {
  BlockLike,
  FunctionDeclaration,
  ScriptTarget,
  getLeadingCommentRanges,
  createSourceFile,
  Node,
  TypeParameterDeclaration,
  Identifier,
  isFunctionDeclaration,
  isIdentifier,
  isObjectLiteralExpression,
  isReturnStatement,
  isShorthandPropertyAssignment,
  isTypeNode,
} from "typescript";

const SRC_FILE = "src/factory.tsx";
const TARGET_FILE = "src/compat.tsx";

const PREAMBLE = `
/**
 * NOTE:
 * This file is AUTOGENERATED!
 *
 * Do not update it manually.
 */
`;

function getDeprecationMessage(hookName: string): string {
  // XXX Use markdown to highlight these

  // XXX Use {@link } syntax to link to new definition

  // XXX Figure out final name of "liveblocks.config" module. Perhaps `room.config`?

  // XXX Upgrade all examples to this new API, and see what we'll hit
  return `
 *
 * @deprecated Support for importing hooks directly from \`@liveblocks/react\`
 * is going to get removed in the next major release (0.18). Please use the new
 * recommended way of importing your hooks.
 *
 * Put the following contents in "./liveblocks.config.ts":
 *
 * \`\`\`
 * import { create } from "@liveblocks/react";
 * export default create<MyPresence, MyStorage>();
 * \`\`\`
 *
 * Then, import from your local module:
 * 
 * \`\`\`
 * import hooks from "./liveblocks.config";
 * const { ${hookName} } = hooks;
 * \`\`\`
`;
}

function getFunctionDeclarations(block: BlockLike): FunctionDeclaration[] {
  return block.statements.filter(isFunctionDeclaration);
}

function findFunctionDeclaration(
  block: BlockLike,
  name: string
): FunctionDeclaration {
  const decl = getFunctionDeclarations(block).find(
    (f) => f.name?.text === name
  );
  if (!decl) {
    throw new Error(`Couldn't find function declaration for "${name}"`);
  }
  return decl;
}

const srcFile = createSourceFile(
  TARGET_FILE,
  readFileSync(SRC_FILE, "utf8"),
  ScriptTarget.ESNext,
  /* setParentNodes */ true
);

const fullSrcText = srcFile.getFullText();

/**
 * Reads the src/factory.tsx source file, and returns the list of
 * function declarations to wrap, e.g. the AST nodes for the definitions of
 * `useList`, `useHistory`, etc.
 */
function getLiveblocksHookDefintions() {
  const liveblocksFactoryFn = findFunctionDeclaration(srcFile, "create");

  // Get all of the things returned by this function. These represent the
  // "exports".
  const exportStm =
    liveblocksFactoryFn.body?.statements?.find(isReturnStatement);
  if (!exportStm) {
    throw new Error("Couldn't find return statement in `create()`");
  }

  const exportedObj = exportStm.expression;
  if (!exportedObj || !isObjectLiteralExpression(exportedObj)) {
    throw new Error("Expected `create()` to return an object literal");
  }

  const exportedNames: string[] = exportedObj.properties.map((p) => {
    if (!isShorthandPropertyAssignment(p)) {
      throw new Error(
        `Exported object expected to only contain shorthand identifiers, but found: "${p.getText()}"`
      );
    }
    return p.name.text;
  });

  // Grab all of the inner function declarations
  const decls: FunctionDeclaration[] = liveblocksFactoryFn.body
    ? getFunctionDeclarations(liveblocksFactoryFn.body)
    : [];

  const fns: (FunctionDeclaration & { name: Identifier })[] = [];
  for (const name of exportedNames) {
    const found = decls.filter(
      (d): d is FunctionDeclaration & { name: Identifier } =>
        d.name?.text === name
    );
    if (found.length === 0) {
      throw new Error("Declaration of " + name + " not found!");
    }
    fns.push(...found);
  }
  return fns;
}

function getCommentForNode(node: Node): string {
  const comms = getLeadingCommentRanges(fullSrcText, node.getFullStart());
  if (comms) {
    return comms.map((r) => fullSrcText.slice(r.pos, r.end)).join("");
  } else {
    return "";
  }
}

/**
 * Take a Liveblocks hook declaration, and returns the source code to wrap it.
 */
function wrapHookDeclaration(
  decl: FunctionDeclaration & { name: Identifier },
  isOverload: boolean,
  hasOverloads: boolean
): string {
  const name = decl.name.text;

  // Extract function parameter names and their type annotations
  const paramDecls = decl.parameters.map((p) => {
    if (!isIdentifier(p.name)) {
      throw new Error("Cannot handle destructuring in arguments");
    }
    if (!p.type || !isTypeNode(p.type)) {
      throw new Error("Param " + p.name.text + " has no type annotation!");
    }
    return { name: p.name, type: p.type, optional: !!p.questionToken };
  });

  function doesReturnTypeNeed(ref: "TPresence" | "TStorage"): boolean {
    return !!decl.type && decl.type.getText().includes(ref);
  }

  function doInputParamsNeed(ref: "TPresence" | "TStorage"): boolean {
    return paramDecls.some(({ type }) => type.getText().includes(ref));
  }

  const extraTPresence =
    doesReturnTypeNeed("TPresence") || doInputParamsNeed("TPresence")
      ? "TPresence extends JsonObject"
      : "";

  const extraTStorage =
    doesReturnTypeNeed("TStorage") || doInputParamsNeed("TStorage")
      ? "TStorage extends LsonObject"
      : "";

  // XXX Replace, don't append deprecation message!
  const jsDocComment = getCommentForNode(decl).replace(
    "*/",
    `${getDeprecationMessage(name).trim()}\n*/`
  );

  const optionalTypeParams: string =
    decl.typeParameters || extraTPresence || extraTStorage
      ? `<${[
          ...[extraTPresence, extraTStorage].filter(Boolean),
          ...(decl.typeParameters ?? []).map(
            (tparam: TypeParameterDeclaration) => tparam.getText()
          ),
        ].join(", ")}>`
      : "";

  const params = paramDecls
    .map(
      ({ name, type, optional }) =>
        `${name.text}${optional ? "?" : ""}: ${type.getText()}`
    )
    .join(", ");

  const optionalReturnType = decl.type ? `: ${decl.type.getText()}` : "";

  // If this is a real function with a body, generate a function with a body
  // here too. Otherwise, it's an overload definition, and we should generate
  // that instead.
  if (!isOverload) {
    const args = paramDecls
      .map(({ name }) => name.text)
      .map((arg) => (hasOverloads ? `${arg} as any` : arg))
      .join(", ");

    const optionalCast =
      decl.type &&
      (doesReturnTypeNeed("TPresence") || doesReturnTypeNeed("TStorage"))
        ? ` as unknown as ${decl.type.getText()}`
        : "";

    const body = `
      deprecate("The direct import for ${name} will get removed in 0.18. Please consider moving to use new-style factory hooks!");
      return _hooks.${name}(${args})${optionalCast};
    `;

    // Put together the final source code
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType} {
        ${body}
      }
    `;
  } else {
    return `
      ${jsDocComment}
      export function ${name}${optionalTypeParams}(${params})${optionalReturnType};
    `;
  }
}

console.log(PREAMBLE);
console.log(`
import type { BroadcastOptions, History, Json, JsonObject, LiveList, LiveMap, LiveObject, Lson, LsonObject, Others, Room, User } from "@liveblocks/client";
import type { RoomProviderProps } from "./factory";
import { create } from "./factory";
import { deprecate } from "@liveblocks/client/internal";

const _hooks = create();
`);

const liveblocksHooks = getLiveblocksHookDefintions();
for (const decl of liveblocksHooks) {
  const isOverload = !decl.body;
  const hasOverloads =
    !isOverload &&
    liveblocksHooks.filter((hook) => hook.name.text === decl.name.text).length >
      1;
  console.log();
  console.log(wrapHookDeclaration(decl, isOverload, hasOverloads));
}
